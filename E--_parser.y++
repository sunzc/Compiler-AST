%{

#include "Ast.h"
#include "ParserUtil.h"
#include "Error.h"
#include "Type.h"

using namespace std;

extern int verbosity;
extern int yylex();
extern void yyerror(const char *s);
int offSet;
extern const OpNode::OpInfo opInfo[];
#define prt(x) cout << x << endl;

%}

%union{
  unsigned int 		 uVal;
  double             dVal;
  char*              cVal;
  vector<string>*    strVector;
  Value*             valVal;

  ExprNode*          exprVal;
  vector<ExprNode*>* exprList;
  RefExprNode*       refexpVal;

  ClassEntry*        classEntry;
  Type*              typeVal;
  vector<Type*>*     typeList; 

  EventEntry*        eventEntry;                        
  VariableEntry*     variableEntry;
  FunctionEntry*     functionEntry;

  BasePatNode*       patVal;
  PrimitivePatNode*  primPatVal;
  StmtNode*          stmtVal;
  list<StmtNode*>*   stmtList;
  IfNode*            ifVal;
  CompoundStmtNode*  compoundStmtVal;
  RuleNode*          ruleNode;

  vector<RuleNode*>* transList;
  
  vector<Type*>*     formalTypeVal;
  const OpNode::OpInfo*    funIval;
};

/* Operators */

%token TOK_LEX_ERROR TOK_PAT_STAR TOK_PAT_OR TOK_PAT_NOT
%token TOK_PLUS TOK_MINUS TOK_UMINUS TOK_MULT TOK_DIV TOK_MOD 
%token TOK_BITAND TOK_BITOR TOK_BITNOT TOK_BITXOR TOK_SHL TOK_SHR 
%token TOK_GT TOK_LT TOK_GE TOK_LE TOK_EQ  TOK_NE TOK_AND TOK_OR TOK_NOT 
%token TOK_COMMA TOK_ASSIGN TOK_SEMICOLON TOK_COLON TOK_ARROW
%token TOK_LBRACE TOK_RBRACE TOK_LPAREN TOK_RPAREN

/* Key words */

%token TOK_IF TOK_ELSE TOK_CLASS TOK_RETURN TOK_EVENT TOK_ANY TOK_PRINT 
%token TOK_UINTNUM TOK_DOUBLENUM TOK_VOID TOK_STRING TOK_STRCONST 
%token TOK_INT TOK_UNSIGNED TOK_BOOL TOK_BYTE TOK_DOUBLE TOK_SHORT
%token TOK_TRUE TOK_FALSE TOK_IDENT

/******************************** Type Info ********************************/
%type <typeList> formal_param_list formal_param_plus 
%type <eventEntry> event_decl_hdr event_decl
%type <typeVal> type baseType 
%type <cVal> TOK_IDENT TOK_PRINT 
/* Uncomment types below as you start adding rules.
   They are commented right now to prevent compile errors.
%type <functionEntry> function_header function_decl
%type <variableEntry> variable_decl formal_param variable_decl1
%type <typeList> formal_param_list formal_param_plus 
%type <eventEntry> event_decl_hdr event_decl
%type <patVal> event_pattern rule_body1
%type <primPatVal> event primitive_pat 
%type <typeVal> type baseType 
%type <exprList> expr_list expr_plus
%type <exprVal> expr function_invocation asg_stmt
%type <refexpVal> ref_expr
%type <ruleNode> rule
%type <strVector> id_list id_plus

%type <cVal> TOK_IDENT TOK_PRINT 
%type <funIval> ev_or_fun
%type <uVal> TOK_UINTNUM 
%type <dVal> TOK_DOUBLENUM 
%type <cVal> TOK_STRCONST

%type <valVal> literal

%type <stmtList> stmt_plus
%type <stmtVal> stmt simple_stmt
%type <compoundStmtVal> compoundStmt fun_rest
%type <ifVal>  if_then_else_stmt 
*/

/*********************   Precedence and Associativity    ********************/

%nonassoc TOK_ASSIGN

%left  TOK_PAT_OR 
%left  TOK_COLON
%left  TOK_PAT_STAR
%right TOK_PAT_NOT

%left  TOK_OR
%left  TOK_AND
%right TOK_NOT

%nonassoc TOK_EQ TOK_NE TOK_GT TOK_LT TOK_GE TOK_LE

%left  TOK_BITOR TOK_BITXOR
%left  TOK_BITAND
%right TOK_BITNOT 
%left  TOK_SHL TOK_SHR

%right TOK_DOUBLE_COLON

%left  TOK_PLUS TOK_MINUS
%left  TOK_MULT TOK_DIV TOK_MOD
%right TOK_UMINUS 

%left  TOK_LBRACK
%left  TOK_DOT

/**************************************************************************/

%start specification
%%


specification: ifc_decl_star rule_star {}; 

ifc_decl_star: /* empty */ {}
| ifc_decl_star ifc_decl {}
| ifc_decl_star error TOK_SEMICOLON {
	errMsg("Syntax error, expecting a declaration");
}
;

ifc_decl: TOK_SEMICOLON {}
| event_decl {}
;

event_decl: event_decl_hdr TOK_LPAREN formal_param_list TOK_RPAREN TOK_SEMICOLON {
	prt("EventDecl");
	// call type() to pass formal_param info to event
	Type *t = new Type($3, Type::TypeTag::EVENT);
	$1->type(t);
	// leave scope
	stm.leaveScope();
	// insert event entry
	stm.insert($1);
	$$ = $1;
}
| TOK_EVENT error TOK_SEMICOLON{
	errMsg("Expected an event name");
}
;

event_decl_hdr: TOK_EVENT TOK_IDENT {
	prt("EventDecl head");
	// create event
	$$ = new EventEntry(string($2));
	// enter scope, TODO what argument should we pass to it?
	SymTabEntry *ste = new SymTabEntry(string("EVENT_BLOCK"), SymTabEntry::Kind::EVENT_BLOCK_KIND, 0, 0, ""); 
	stm.enterScope(ste);
}
;

formal_param_list: /* empty */ {
	// NULL for empty list
	$$ = 0;
}
| formal_param_plus{
	prt("FormalParamList");
	// assign $1 to $$
	$$ = $1;
}
;

formal_param_plus: type TOK_IDENT {
	prt("FormalParam");
	// First, create sym tab entry for TOK_IDENT, remember we have entered a new scope
	VariableEntry *var = new VariableEntry(string($2), VariableEntry::VarKind::PARAM_VAR, $1);
	stm.insert(var);
	
	//if $$ doesnot equal NULL, Construct it and append $1 to it
	$$ = new vector<Type*>();
	auto it = $$->end();

	$$->insert(it, $1);
}
| formal_param_plus TOK_COMMA type TOK_IDENT {
	prt("FormalParam");
	// First, create sym tab entry for TOK_IDENT, remember we have entered a new scope
	VariableEntry *var = new VariableEntry(string($4), VariableEntry::VarKind::PARAM_VAR, $3);
	stm.insert(var);

	// construct Type(type TOK_IDENT)
	// if append new type to $1
	auto it = $1->end();
	$1->insert(it, $3);
	$$ = $1;
}
;

/* TODO: type name will conflict with assignment statement */
type: TOK_IDENT {
	prt("Type");
	// construct type and assign
	$$ = new Type(Type::TypeTag::UNKNOWN);
}
| baseType {
	prt("Type");
	// assign $1 to $$
	$$ = $1;
}
| TOK_UNSIGNED baseType {
	prt("Type");
	// construct new type and assign it to $$
	// check possible value, we only support "unsigned int" here
	if ($2->isInt($2->tag())) {
		$$ = new Type(Type::TypeTag::UINT);
	}else{
		errMsg("Unsupport type!\n");
		$$ = new Type(Type::TypeTag::UNKNOWN);
	}
}
;

baseType: TOK_VOID {
	// just construct type and assign is ok
	$$ = new Type(Type::TypeTag::VOID);
}
| TOK_BOOL {
	$$ = new Type(Type::TypeTag::BOOL);
}
| TOK_STRING {
	$$ = new Type(Type::TypeTag::STRING);
}
| TOK_BYTE {
	$$ = new Type(Type::TypeTag::BYTE);
}
| TOK_INT {
	$$ = new Type(Type::TypeTag::INT);
}
| TOK_DOUBLE {
	$$ = new Type(Type::TypeTag::DOUBLE);
}
;

rule_star: /* empty */ {
	errMsg("Must contain at least one rule");
}
| rule_list {
}
;

rule_list: rule_decl {}
| rule_list rule_decl {}
| rule_list error TOK_SEMICOLON {
	errMsg("Error, expecting a rule");
}
;

rule_decl: event_pattern TOK_ARROW stmt {
	prt("Rule");
}
| event_pattern error TOK_SEMICOLON{
	errMsg("Syntax error, skipping event pattern");
}
;

event_pattern: primitive_pattern{
	prt("PrimitivePat");
}
;


primitive_pattern: TOK_ANY {
	prt("anyEvent");
} /* TODO: should TOK_ANY be included in a computation ? */
| TOK_IDENT TOK_LPAREN param_star TOK_RPAREN {
	prt("NormalEvent");
}
;

param_star: /* empty */ {}
| param_list {}
;

param_list: TOK_IDENT {
	prt("EventFormalParam");
} /* TODO not sure whether empty param is allowed or not in event */ 
| param_list TOK_COMMA TOK_IDENT {
	prt("EventFormalParam");
}
;

stmt_list: stmt {}
| stmt_list stmt {}
;

stmt: TOK_SEMICOLON {} /* empty statement */
| compound_stmt {} 
| error TOK_SEMICOLON{
	errMsg("Syntax error while parsing a statement");
}
;

compound_stmt: TOK_LBRACE stmt_list TOK_RBRACE TOK_SEMICOLON{
	prt("CompoundStmt");
}
;

%%
